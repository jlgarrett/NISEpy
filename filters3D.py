# -*- coding: utf-8 -*-
"""
Created on Tue Jan 23 10:07:52 2018

@author: joe
"""

import numpy as np
import scipy
from scipy.integrate import dblquad

'''This file is for calculating the patch filters to process an image. Both
the actual processing of KPFM data, and the calculation of the force from the 
images can be found in 'force3D.py'. The function 'completefiltering' creates
the filter, for a given number of pixes, pixel size, heights, when the function
is specified. It acts using the functions preceding it.'''


def patchIntegrand( label = ""):
    '''Calculates the radial integral of the filter to apply to the patch 
    potential image for a particular force setting. x has been normalized by 
    the radius. 
    
    The label can be:
    
    'fs' for force from same surface
    'fo' for force from opposite surfaces
    'fds' for force derivative from same surface
    'fdo' for force derivative from other surface'''
     
    #Return a function based on the input 
    if label == 'fs':
        def intfunc(dor, x):
            return dor**4 * x**3 / (np.sinh(x*dor))**2 * scipy.special.j0(x)
        return intfunc
    elif label == 'fo': 
        def intfunc(dor, x):
            return dor**4 * x**3 / (np.sinh(x*dor))**2 * np.cosh(x*dor) \
            * scipy.special.j0(x)
        return intfunc
    elif label == 'fds':
        def intfunc(dor, x):
            return dor**5 * x**4 / (np.sinh(x*dor))**3 * np.cosh(x*dor) \
            * scipy.special.j0(x)
        return intfunc
    elif label == 'fdo':
        def intfunc(dor, x):
            return dor**5 * x**4 / (np.sinh(x*dor))**3 * (np.cosh(x*dor)**2 
            + 1) * scipy.special.j0(x)
        return intfunc
    else:
        return 0

def integrate_rad(rfunc, minpoint, maxpoint):
        '''Integrates the function rfunc from minpoint to maxpoint (tuples).
        Includes code to prevent integral from going wild at small values'''
        p1 = minpoint
        p2 = maxpoint
        #If we let the function get too small, the integral never converges
        if rfunc( np.sqrt(p1[0]**2+p2[0]**2) ) < 1e-1: 
            return 0
        else:
            return dblquad(lambda x,y: rfunc( np.sqrt(x**2+y**2)), p1[0], p2[0],
                           lambda x: p1[1], lambda x: p2[1], epsabs=1.49e-08)[0]
        
def define_filter( rfunc , side_n , spacing ):
    '''Calculates the patch potential filter from a radially-symmetric function.
    rfunc is the function in terms of $r$. side_n is the number of pixels per
    side, which must be odd, for symmetry reasons, and spacing is the spacing 
    between the centers of the pixels'''
    if side_n %2 == 0:
        print('Side must have odd number of pixels')
        return 0
    else:
        #We define indices to give the coordinates of all the points
        indices = [[(i,j) for i in range(-(side_n-1)//2,(side_n+1)//2)] \
        for j in range(-(side_n-1)//2,(side_n+1)//2)]
        #only one eighth of the filter is filled out because the rest is 
        #implied by radial symmetry
        rfilter = np.array([[0.0 for i in range(-(side_n-1)//2,(side_n+1)//2)]\
            for j in range(-(side_n-1)//2,(side_n+1)//2)])     
        
        #We fill in the filter by integrating over the radial function
        for i in range((side_n-1)//2,(side_n)):
            for j in range(i,(side_n)):
                p1 = tuple(spacing*indices[i][j][k]-spacing/2 for k in range(2))
                p2 = tuple(spacing*indices[i][j][k]+spacing/2 for k in range(2))
                inte = integrate_rad(rfunc, p1 ,p2)
                rfilter[i][j] = inte
        
        return rfilter

def internal_integral( dor , force_inte = 0):
    '''Integrates over the function force_inte. Assumes a force of the type
    generated by patchIntegrand()'''
    if force_inte == 0:
        force_inte = patchIntegrand('fs')
    return scipy.integrate.quad(lambda x: force_inte(x,dor),0,100/dor, 
                                epsabs = 1e-12, limit = 2000)[0]

def ii_array( dors , force_integ = 0):
    '''Creates an array of integrals of a function for many separations. 
    Assumes a function of the form of patchIntegrand()'''
    if force_integ == 0:
        force_integ = patchIntegrand('fs')
    output = dors
    for i in range(len(dors)):
        output[i] = internal_integral( dors[i] , force_integ)
    
    return output

class InterpRes:
    '''This class stores the interpolation of a radial function describing
    the correlation between different points on a patch potential image. It is 
    useful because it stores the data on a log-log scale, if it can, but stores
    it on a log-linear scale if necessary. The keywords are:
    start -- is the smallest x value
    end -- is the largest x value to be interpolated
    func_2_interpolate -- is the function to be interpolated.'''
    def __init__(self, start=0.09, end=10**5, func_2_interpolate=0):
        #print(start,end)
        if func_2_interpolate == 0:
            func_2_interpolate = patchIntegrand('fs')
        self.startpoint = start
        self.endpoint = end
        lnx = np.linspace(np.log(start), np.log(end), num=100, endpoint=True)
        ys = ii_array(np.exp(lnx), func_2_interpolate)
        if min(ys) > 0:
            lny = np.log(ys)
            self.ispos = True
            self.loginterp = scipy.interpolate.interp1d(lnx, lny, kind = 'cubic')
        else:
            self.loginterp = scipy.interpolate.interp1d(lnx, ys, kind = 'cubic')
            self.ispos = False
            def basic(self, x):
                '''
                basic returns the part of the function independent of height
                '''
                if (x < self.endpoint )& (x > self.startpoint):
                    return self.loginterp(np.log(x))
                elif x < self.endpoint:
                    return 0
                else:
                    return self.loginterp(np.log(self.endpoint))    
   
    def basic(self, x):
        '''
        basic returns the part of the function independent of height
        '''
        if (x < self.endpoint )& (x > self.startpoint):
            if self.ispos:
                return np.exp(self.loginterp(np.log(x)))
            else:
                return self.loginterp(np.log(x))
        elif x < self.endpoint:
            return 0
        else:
            if self.ispos:
                return np.exp(self.loginterp(np.log(self.endpoint)))
            else: 
                return self.loginterp(np.log(self.endpoint))
                
    def transformed(self, h, r):
        '''
        returns the interpolated function once the height has been included
        '''
        if r>0:
            return self.basic(h/r)/h**2/(np.pi**2)
        else:
            return self.basic(self.endpoint)/h**2/(np.pi**2)
    
    def singleh(self, h):
        '''singleh returns a function to give the value of the interpolation
        at a single height, for all possible radii
        '''
        def rfunc( r ):
            return self.transformed(h, r)
        return rfunc

def filter_h_pixels(hs, nside, rinterp, dx):
    '''This function generates the patch potential filter as a function of 
    position. A dictionary which gives the filter as a function of height
    for each pixel is output. The inputs are:
    hs -- a list of all the heights
    nside -- the number of pixels in the filter
    rinterp -- the function interpolated by radius
    dx -- the spacing between pixels'''
    fullfilt = [[[0 for i in range(1,j+1)] for j in range(1,(nside+3)//2)] \
    for k in range(len(hs))]
    locs = [(i-1,j-1) for j in range(1,(nside+3)//2) for i in range(1,j+1)] 
    
    for i in range(len(hs)):
        rfunc = rinterp.singleh(hs[i])
        locfilt = define_filter(rfunc,nside, dx)
        print(i)
        
        for j in range((nside+1)//2):
            for k in range(j+1):
                fullfilt[i][j][k] = locfilt[(nside-1)//2+k,(nside-1)//2+j]

    pixels = {j:[fullfilt[i][j[1]][j[0]] for i in range(len(hs))] for j in locs}            
    pixels['separation'] = hs
    
    return pixels
    
def complete_filtering(hs, nside, rlabel, dx):
    '''This function generates a filter of a given pixel size and list of 
    heights for a given radial function. The inputs are:
    hs -- heights
    nside -- the number of pixels on each side of the filter
    rlabel -- the type of function to use (see patchIntegrand())
    dx -- the spacing between pixel centers'''
    rfunc = InterpRes(func_2_interpolate = patchIntegrand(rlabel))
    mainfilter = filter_h_pixels(hs, nside, rfunc, dx)
    return mainfilter
    
def expand_filter( filt ):
    halfside = (filt.shape[0]-1)//2
    print(halfside)
    exp_filt = filt
    for i in range(halfside, 2*halfside+1):
        for j in range(halfside,i):
            exp_filt[i][j] = exp_filt[j][i]
    
    exp_filt[halfside:,:halfside] = exp_filt[halfside:,:halfside:-1]
    exp_filt[:halfside] = exp_filt[:halfside:-1]
    return exp_filt